EventEmitter3.js

// const EvEmitter = require('events')
/*
This will import the name property from the exports of event4.js and assign it to a local variable named 
NewClass. Then you can use it to create a new instance of the NewClass class
*/
const {myClassLogger: NewClass} = require('./EventEmitter4.js')
const myMessage = new NewClass()

myMessage.addListener('Message', function(eventArg){ 
    console.log('Listener Called', eventArg)
})

console.log(myMessage)
myMessage.myEvent('Ishita')

/*
Even if you don't write const EvEmitter = require('events') it is OK because - 
The addListener method is inherited from the EventEmitter class in the events module. In your code, the 
NewClass class extends the EventEmitter class, which means that it inherits all of its methods, including the 
addListener method.

When you create a new instance of the NewClass class using const myMessage = new NewClass(), the resulting 
object has access to all the methods of both the NewClass class and its parent class, EventEmitter. That’s 
why you can call the addListener method on the myMessage object even though you didn’t explicitly define it 
in your code.

In other words, when you call myMessage.addListener(...), JavaScript looks for the addListener method on the 
myMessage object. If it doesn’t find it there, it looks for it on the prototype of the myMessage object, 
which is the prototype of the NewClass class. If it doesn’t find it there either, it looks for it on the 
prototype of the parent class, which is the prototype of the EventEmitter class. Since the EventEmitter class
has an addListener method, JavaScript finds it there and calls it with the arguments you provided.
*/

/*
If we write this code it will not work
const {myClassLogger: NewClass} = require('./EventEmitter4.js')

NewClass.addListener('Message', function(eventArg){ 
    console.log('Listener Called', eventArg)
})

console.log(NewClass)
NewClass.myEvent('Ishita')

The code you provided will not work because NewClass is a reference to the Logger class itself, not an instance of 
the class. The addListener and myEvent methods are instance methods, which means they can only be called on 
instances of the Logger class, not on the class itself.

In order to use the addListener and myEvent methods, you need to create a new instance of the Logger class by 
calling its constructor with the new keyword. You can do this by calling the methods on the myMessage object, which 
is an instance of the Logger class.

A detailed explanation of Class - 
A class is a blueprint for creating objects, while an instance of a class is an actual object created using that 
blueprint. When you define a class, you specify the properties and methods that instances of that class will have. 
However, the class itself does not have those properties and methods - only instances of the class do.

For example, let’s say you have a Car class that has a drive method. You can create multiple instances of the Car 
class, each representing a different car. Each car can drive independently of the others, and each car can have its 
own state (such as its current speed or location). However, the Car class itself does not have a current speed or 
location - those are properties of individual instances of the Car class
*/

/*
In the line `const {myClassLogger: NewClass} = require('./EventEmitter4.js')`, you are using object destructuring 
and renaming syntax to import the `myClassLogger` property from the object exported by `EventEmitter4.js` and 
assign it to a new variable called `NewClass`. This means that `NewClass` is now a reference to the value of the 
`myClassLogger` property exported by `EventEmitter4.js`.

In `EventEmitter4.js`, you have defined a class called `Logger` that extends the `EventEmitter` class from the 
`events` module. This means that instances of the `Logger` class will have all the properties and methods of the 
`EventEmitter` class, as well as any additional properties and methods that you define in the `Logger` class. You 
then assign the `Logger` class to the `myClassLogger` property of the object that you export from `EventEmitter4.js`.

When you import the `myClassLogger` property from `EventEmitter4.js` and assign it to the variable `NewClass`, you 
are essentially creating a new reference to the `Logger` class. This means that when you call `new NewClass()`, you 
are creating a new instance of the `Logger` class. This instance will have all the properties and methods of the 
`EventEmitter` class, as well as any additional properties and methods that you defined in the `Logger` class.

In summary, when you use object destructuring and renaming syntax to import the `myClassLogger` property from 
`EventEmitter4.js`, you are creating a new reference to the value of that property, which is the `Logger` class. 
When you create a new instance of this class using the `new` keyword, you get an object that has all the properties 
and methods defined by both the `EventEmitter` and `Logger` classes.
*/

------------------------------------------------------------------------------------------------------------------

EventEmitter4.js

const EvEmitter = require('events')
var url = 'http://mylogger/io/log'

class Logger extends EvEmitter{
    myEvent(message){ // When a function is inside a class we say it is a method of that class
        // Send an HTTP request
        console.log(message)

        // Raise an event
        this.emit('Message', {id: 1, url: 'https://abc.com'})
    }
}
module.exports.myClassLogger = Logger
module.exports.url = url

/*
this.emit is a method call that emits an event. The emit method is a method of the EventEmitter class from the 
events module, which the Logger class extends. This means that instances of the Logger class have access to the 
emit method.

In JavaScript, the `this` keyword refers to the object that the current function is being called on. It allows you 
to access the properties and methods of that object from within the function.

In the code you provided earlier, the `myEvent` method of the `Logger` class is calling `this.emit('Message', {id: 
1, url: 'https://abc.com'})`. In this case, `this` refers to the instance of the `Logger` class that the 
`myEvent` method is being called on. By calling `this.emit`, the `myEvent` method is calling the `emit` method on 
that instance of the `Logger` class.

Using `this` is necessary in this case because the `emit` method is an instance method of the `EventEmitter` class, 
which means it can only be called on instances of that class (or classes that extend it, like the `Logger` class). 
By calling `this.emit`, you are calling the `emit` method on the specific instance of the `Logger` class that the 
`myEvent` method is being called on.

In summary, you need to use `this` in order to call instance methods and access instance properties of the object 
that a function is being called on. In this case, it allows you to call the `emit` method on a specific instance of 
the `Logger` class.

You cannot call myEvent.emit because myEvent is a method of the Logger class, not an instance of the Logger class 
or the EventEmitter class. The emit method is an instance method of the EventEmitter class, which means it can only 
be called on instances of that class (or classes that extend it, like the Logger class).
*/

Method vs Instance of a Class
An instance of a class, on the other hand, is an object that is created using the class as a blueprint. When you \
create an instance of a class using the new keyword, you get an object that has its own set of properties and 
methods as defined by the class. You can then call methods on that instance to manipulate its data or perform 
actions.
In summary, a method is a function associated with an object or class, while an instance of a class is an actual 
object created using the class as a blueprint. Methods operate on the data of the object they are called on, while 
instances have their own set of data and methods as defined by the class.

Real Life examples of Method vs Instance of Class
Sure! Here's an example that might help illustrate the difference between a method and an instance of a class:

Let's say you have a `BankAccount` class that represents a bank account. This class might have properties like 
`balance` and `accountNumber`, and methods like `deposit` and `withdraw`.

An instance of the `BankAccount` class would represent a specific bank account. For example, you might create an 
instance of the `BankAccount` class for your own personal bank account. This instance would have its own `balance` 
and `accountNumber` properties that represent the balance and account number of your bank account.

The methods of the `BankAccount` class, such as `deposit` and `withdraw`, would allow you to manipulate the data of 
a specific instance of the class. For example, you could call the `deposit` method on your personal bank account 
instance to increase its balance, or call the `withdraw` method to decrease its balance.

In this example, the `BankAccount` class defines the properties and methods that instances of the class will have, 
while instances of the class represent specific bank accounts with their own data. The methods of the class allow 
you to manipulate the data of specific instances.

Here's another example: Imagine a `Car` class that represents a car. This class might have properties like `make`, 
`model`, and `speed`, and methods like `accelerate` and `brake`.

An instance of the `Car` class would represent a specific car. For example, you might create an instance of the 
`Car` class for your own car. This instance would have its own `make`, `model`, and `speed` properties that 
represent the make, model, and current speed of your car.

The methods of the `Car` class, such as `accelerate` and `brake`, would allow you to manipulate the data of a 
specific instance of the class. For example, you could call the `accelerate` method on your car instance to 
increase its speed, or call the `brake` method to decrease its speed.

In this example, the `Car` class defines the properties and methods that instances of the class will have, while 
instances of the class represent specific cars with their own data. The methods of the class allow you to 
manipulate the data of specific instances.
-----------------------------------------------------------------------------------------------------------------
An object is a data structure that contains data and functions, while an instance of a class is a specific example 
of an object created using a class as a blueprint. A method is a function associated with an object or class that 
can be called to manipulate its data or perform actions.